<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NumPy: Quick Start | Sunset's Citywalk</title><meta name="author" content="Sunset"><meta name="copyright" content="Sunset"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="NumPy - Quick Start 1. 基础知识 NumPy的主要对象是同构多维数组。它是一个元素表（通常是数字），所有类型都相同，由非负整数元组索引。在NumPy中维度称为 轴 。 NumPy的数组类是ndarray，别名是array。请注意，numpy.array与标准Python库类array.array不同，后者只能处理一维数组。 1.1 ndarray的主要属性  n">
<meta property="og:type" content="article">
<meta property="og:title" content="NumPy: Quick Start">
<meta property="og:url" content="https://laaambs.github.io/2023/08/25/NumPy-Quick-Start/index.html">
<meta property="og:site_name" content="Sunset&#39;s Citywalk">
<meta property="og:description" content="NumPy - Quick Start 1. 基础知识 NumPy的主要对象是同构多维数组。它是一个元素表（通常是数字），所有类型都相同，由非负整数元组索引。在NumPy中维度称为 轴 。 NumPy的数组类是ndarray，别名是array。请注意，numpy.array与标准Python库类array.array不同，后者只能处理一维数组。 1.1 ndarray的主要属性  n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://laaambs.github.io/images/cover.jpg">
<meta property="article:published_time" content="2023-08-25T04:18:23.000Z">
<meta property="article:modified_time" content="2023-08-25T04:19:48.706Z">
<meta property="article:author" content="Sunset">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="NumPy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://laaambs.github.io/images/cover.jpg"><link rel="shortcut icon" href="/images/coffee_shop.png"><link rel="canonical" href="https://laaambs.github.io/2023/08/25/NumPy-Quick-Start/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Sunset","link":"链接: ","source":"来源: Sunset's Citywalk","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NumPy: Quick Start',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-25 12:19:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/rabbit.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Sunset's Citywalk"><img class="site-icon" src="/images/coffee_shop.png"/><span class="site-name">Sunset's Citywalk</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NumPy: Quick Start</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-25T04:18:23.000Z" title="发表于 2023-08-25 12:18:23">2023-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-25T04:19:48.706Z" title="更新于 2023-08-25 12:19:48">2023-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%A3%E7%A0%81/">代码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NumPy: Quick Start"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="numpy---quick-start">NumPy - Quick Start</h1>
<h2 id="基础知识">1. 基础知识</h2>
<p>NumPy的主要对象是同构多维数组。它是一个元素表（通常是数字），所有类型都相同，由非负整数元组索引。在NumPy中维度称为
轴 。</p>
<p>NumPy的数组类是ndarray，别名是array。请注意，numpy.array与标准Python库类array.array不同，后者只能处理一维数组。</p>
<h3 id="ndarray的主要属性">1.1 ndarray的主要属性</h3>
<ul>
<li>ndarray.ndim - 返回数组有几个维度</li>
<li>ndarray.shape -
返回数组的形状，用元组表示，元组的第i个值表示数组第i个维度上有几个元素</li>
<li>ndarray.size -
返回数组中一共含有多少个元素，即shape函数返回元组中各数值的乘积</li>
<li>ndarray.dtype -
返回数组元素的类型，ndarray是同构多维数组，所有元素类型相同</li>
<li>ndarray.itemsize - 返回数组每个元素的字节大小</li>
<li>ndarray.data -
缓冲区中指向数组第一个数据的指针。很少使用，一般用索引来访问数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.ndim)</span><br></pre></td></tr></table></figure>
<pre><code>2</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>(3, 5)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.size)</span><br></pre></td></tr></table></figure>
<pre><code>15</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>int32</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.itemsize)</span><br></pre></td></tr></table></figure>
<pre><code>4</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.data)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;memory at 0x000002423E72C5F0&gt;</code></pre>
<h3 id="数组创建">1.2 数组创建</h3>
<p>数组创建通常有三类方法： 1.
用已有的python列表、元组等序列转换生成ndarray 2.
生成一定大小的ndarray，但没有具体的数值，而是用一些初始化的占位符代替 3.
生成处于一定数值范围的ndarray 下面给出这三类方法的具体示例</p>
<h4 id="用python序列创建数组">1.2.1 用python序列创建数组</h4>
<ul>
<li>可以用python的列表、元组等序列对象直接生成数组，得到的数组的类型是从Python列表中元素的类型推导出来的。</li>
<li>可以用python序列的序列、或者序列的序列的序列生成多维数组，以此类推</li>
<li>利用np.array()函数进行创建，注意array应该接受一个序列对象，而不是一串数字参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a, a.dtype)</span><br><span class="line">b = np.array((<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(b, b.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[1 2 3 4 5] int32
[ 6  7  8  9 10] int32</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.ndim,a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1  2  3  4  5]
 [ 6  7  8  9 10]]
2 (2, 5)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a = np.array(1,2,3,4,5) # wrong</span></span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># right</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[1 2 3 4 5]</code></pre>
<h4 id="元素未知时创建一定大小的数组">1.2.2
元素未知时创建一定大小的数组</h4>
<p>通常，数组的元素最初是未知的，但它的大小是已知的。因此，NumPy提供了几个函数来创建具有初始占位符内容的数组。这就减少了数组增长的必要，因为数组增长的操作花费很大。
+
np.zeros()，np.ones()函数分别可以创建一定大小的初始值全为0、初始值全为1的数组
+
np.empty()可以创建制定大小，初始值全为随机值的数组，创建的值取决于内存的状态
+
注意以上函数的接收参数都要是一个shape元组，并且默认情况下生成数组的dtype为float64，也可以通过dtype参数指定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a,a.dtype)</span><br><span class="line">b = np.zeros((<span class="number">2</span>,<span class="number">3</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(b,b.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[[0. 0. 0.]
 [0. 0. 0.]] float64
[[0 0 0]
 [0 0 0]] int32</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a,a.dtype)</span><br><span class="line">b = np.ones((<span class="number">2</span>,<span class="number">3</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(b,b.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[[1. 1. 1.]
 [1. 1. 1.]] float64
[[1 1 1]
 [1 1 1]] int32</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.empty((<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 以下生成的值是重启内核后得到的，否则得到了全为1的初始化数组</span></span><br><span class="line"><span class="built_in">print</span>(a, a.dtype)</span><br><span class="line">b = np.empty((<span class="number">2</span>,<span class="number">3</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(b, b.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[[1.01582801e+094 3.54586565e+068 1.57001898e+155]
 [3.71754479e+177 3.97949006e-315 0.00000000e+000]] float64
[[538976288 538976288 842095451]
 [858857516 537537629 538976288]] int32</code></pre>
<h4 id="从指定区间采样创建数组">1.2.3 从指定区间采样创建数组</h4>
<p>为了创建数字组成的数组，NumPy提供了arange()和linspace()。 +
np.arange()会生成一个数组，这个数组是通过从一个指定区间均匀采样得到的。需要向arange()传入start(opt.),stop和step(opt.)，注意区间是左闭右开，不会取到stop值，start的默认取值是0，step的默认取值是1
+
np.linspace()会生成一个数组，这个数组也是通过从一个指定区间均匀采样得到的。需要向linspace()传入start,stop,num(opt.),endpoint等参数，num默认是50，endpoint表示是否包含stop，默认是True，即最后一个元素是stop
+
linspace()是通过指定元素个数来生成数组，arange()是通过指定步长来生成数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a, a.dtype)</span><br><span class="line">b = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(b, b.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5 6 7 8 9] int32
[0 1 2 3 4 5 6 7 8 9] int32</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(a, a.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[0.  0.5 1.  1.5] float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(a,a.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10.] float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a,a.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556
  6.66666667  7.77777778  8.88888889 10.        ] float64</code></pre>
<h3 id="打印数组">1.3 打印数组</h3>
<p>当打印数组时，NumPy用以下布局显示数组： + 最后一个维度从左到右打印，
+ 倒数第二个从上到下打印， +
其余维度也从上到下打印，每个切片用空行分隔。
然后将一维数组打印成列表，二维数组打印成矩阵，三维数组打印成矩阵数组（用空行分隔）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">36</span>).reshape(<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1  2  3  4  5]
  [ 6  7  8  9 10 11]]

 [[12 13 14 15 16 17]
  [18 19 20 21 22 23]]

 [[24 25 26 27 28 29]
  [30 31 32 33 34 35]]]</code></pre>
<p>如果数组太大而无法打印，NumPy会自动跳过数组的中心部分并仅打印角点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10000</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[   0    1    2 ... 9997 9998 9999]</code></pre>
<h3 id="基本操作">1.4 基本操作</h3>
<ul>
<li>算术算子是元素级地应用于array</li>
<li>进行算数运算时，会生成一个新的array来保存结果</li>
<li>算术算子包括加减乘除、指数运算、布尔运算等</li>
<li>array如果与一个scalar进行算术运算，那么这个scalar按元素地应用于array中的每个元素；array如果与另一个矩阵进行算术运算，则两个矩阵的形状必须相等或者是可以进行广播的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">c = a - b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(b**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> * np.sin(a))</span><br><span class="line"><span class="built_in">print</span>(a &lt; <span class="number">35</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3]
[20 29 38 47]
[0 1 4 9]
[ 9.12945251 -9.88031624  7.4511316  -2.62374854]
[ True  True False False]</code></pre>
<p>numpy中矩阵之间的乘法分为elementwise product以及matrix product +
'*'表示执行elmentwise product + '@'或dot()表示执行matrix product +
matrix product的结果是矩阵顺序决定的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = np.array([[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1]
 [2 3]]
[[2 2]
 [2 2]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a*b)</span><br></pre></td></tr></table></figure>
<pre><code>[[0 2]
 [4 6]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a@b)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 2  2]
 [10 10]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.dot(b))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 2  2]
 [10 10]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(b.dot(a))</span><br></pre></td></tr></table></figure>
<pre><code>[[4 8]
 [4 8]]</code></pre>
<ul>
<li>算术运算是创建一个新数组来保存计算结果的，但是有些运算符号，比如'+=','*='是原地执行的，即将结果覆盖掉被操作数组的原数据</li>
<li>当不同dytpe的数组一起被计算时，结果数组与更精确的数组对齐(upcasting，即向上转换)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">3</span>, dtype=np.int32)</span><br><span class="line">b = np.linspace(<span class="number">0</span>, np.pi, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b.dtype)</span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c,c.dtype)</span><br></pre></td></tr></table></figure>
<pre><code>float64
[1.         2.57079633 4.14159265] float64</code></pre>
<ul>
<li>ndarray类中封装了很多一元操作，例如sum(),min(),max()</li>
<li>默认情况下，这些一元操作是全局地应用于数组，即无论数组的形状如何，结果都与将数组拉伸为列表后的结果相同</li>
<li>也可以通过axis参数来指定在数组的哪个维度上应用一元操作</li>
<li>根据数组的打印规则，数组的最后一个维度数据是从左到右打印的，所以数组最外面的维度为0，最里面的维度最大</li>
<li>沿着某个axis操作，就相当于将数组该维度压缩为1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>())</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1 2]
 [3 4 5]]
15
5
0</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[ 3 12]
[3 5 7]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[2 5]</code></pre>
<h3 id="通函数">1.5 通函数</h3>
<p>Numpy提供了一些常见的数学函数，如sin(),cos(),exp(),sqrt()，这些函数是按元素级地应用于数组，被称为Universal
Function + 这些函数输入一个矩阵，输出一个新矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sqrt(a))</span><br></pre></td></tr></table></figure>
<pre><code>[0.         1.         1.41421356 1.73205081]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.sin(a))</span><br></pre></td></tr></table></figure>
<pre><code>[0.         0.84147098 0.90929743 0.14112001]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.exp(a))</span><br></pre></td></tr></table></figure>
<pre><code>[ 1.          2.71828183  7.3890561  20.08553692]</code></pre>
<h3 id="索引切片和迭代">1.6 索引、切片和迭代</h3>
<ul>
<li>一维数组可以进行索引和切片操作，和python的List一样</li>
<li>多维数组也可以进行索引和切片操作，多维数组每个axis上都有索引，要访问多维数组中的某个元素，需要用多个维度的索引组成元组来访问，每个索引用逗号分隔</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">36</span>).reshape(<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1  2  3  4  5]
  [ 6  7  8  9 10 11]]

 [[12 13 14 15 16 17]
  [18 19 20 21 22 23]]

 [[24 25 26 27 28 29]
  [30 31 32 33 34 35]]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<pre><code>0</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[:,<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[ 0 12 24]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[:,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4  5]
 [12 13 14 15 16 17]
 [24 25 26 27 28 29]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[:,<span class="number">0</span>,:])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4  5]
 [12 13 14 15 16 17]
 [24 25 26 27 28 29]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,<span class="number">1</span>,:])</span><br></pre></td></tr></table></figure>
<pre><code>[ 6  7  8  9 10 11]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,:-<span class="number">1</span>,<span class="number">0</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[[24 25 26 27]]</code></pre>
<ul>
<li>当多维数组提供的索引个数小于维度个数时，缺失的维度就默认为全切片，即用':'代替缺失维度的索引</li>
<li>对于多维数组，如果有维度的索引为全切片，也可以用'...'代替一个或连续多个':'</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,:,:])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]]
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,...])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]]</code></pre>
<ul>
<li>数组的迭代是与第一个维度对齐的</li>
<li>对于一维数组，其迭代就是列举每个元素</li>
<li>对于多维数组，其迭代就是列举其第0维上的元素</li>
<li>如果想对多维数组的所有元素进行迭代，可以使用.flat属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
3
4</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1]
[2 3]
[4 5]
[6 7]
[8 9]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">20</span>).reshape(<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a: </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1]
 [2 3]]
[[4 5]
 [6 7]]
[[ 8  9]
 [10 11]]
[[12 13]
 [14 15]]
[[16 17]
 [18 19]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.flat)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;numpy.flatiter object at 0x0000022425FA6F20&gt;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a.flat:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</code></pre>
<h2 id="形状操作">2. 形状操作</h2>
<h3 id="修改数组的形状">2.1 修改数组的形状</h3>
<p>数组的形状是指数组每个维度上元素的个数，所组成的元组</p>
<p>以下函数/属性都可以返回一个修改形状后的数组，而不改变原数组 +
reshape():ndarray.reshape()传参可以是分离的形状参数，也可以是一个元组，其中包括待修改的形状
+ T:ndarray.T将数组转置 + 一维数组转置后不变 +
二维数组转置得到的是标准转置后的矩阵 +
n维数组转置，默认情况下是将原数组的shape做一个翻转；也可以指定特定的axis顺序
+ ravel():将原矩阵以C-style拉伸成一个一维数组，返回新数组 + 区分： +
reshape()的执行逻辑是，将原数组先进行ravel，即以C-style拉伸成一维数组，然后对这个一维数组，按照传入形状的第一个维度进行划分，然后对每个子数组按照第二个维度进行划分，直到划分完毕，生成新形状的数组
+
T不改变原数组中元素的排列，而是换一个view（角度）看待这个多维数组。将一个(4,3,2)的数组想象成一个长方形，转置得到的(2,3,4)数组就是换一个角度看待这个长方形，长方形并没有发生任何变化，但在新view下，它的长宽高变了</p>
<p>上述函数都是返回一个修改形状的矩阵，原矩阵不发生变化；resize()函数的执行逻辑与reshape()相同，不同的是它直接在原矩阵上进行修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(a,a.shape)</span><br><span class="line"><span class="built_in">print</span>(a.reshape(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11] (12,)
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
(12,)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.ravel())</span><br></pre></td></tr></table></figure>
<pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.T)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.ravel())</span><br></pre></td></tr></table></figure>
<pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a.T.ravel()) <span class="comment">#将a.T以C-style拉伸成一维数组返回</span></span><br></pre></td></tr></table></figure>
<pre><code>[ 0  4  8  1  5  9  2  6 10  3  7 11]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同维度的数组进行转置</span></span><br><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.T)</span><br></pre></td></tr></table></figure>
<pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11]
[ 0  1  2  3  4  5  6  7  8  9 10 11]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.T)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">24</span>).reshape(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.T)</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1]
  [ 2  3]
  [ 4  5]]

 [[ 6  7]
  [ 8  9]
  [10 11]]

 [[12 13]
  [14 15]
  [16 17]]

 [[18 19]
  [20 21]
  [22 23]]]
[[[ 0  6 12 18]
  [ 2  8 14 20]
  [ 4 10 16 22]]

 [[ 1  7 13 19]
  [ 3  9 15 21]
  [ 5 11 17 23]]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line">a.resize(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
(3, 4)
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]]
(2, 6)</code></pre>
<h3 id="不同的数组进行堆叠">2.2 不同的数组进行堆叠</h3>
<ul>
<li><p>np.vstack():vertical_stack，将数组序列沿着第0维度堆叠</p></li>
<li><p>传入参数是数组序列</p></li>
<li><p>输入的数组除了第0维度，其余维度的形状必须相同</p></li>
<li><p>如果输入的都是一维数组，则会将一维数组变形为(1,n)，然后沿第0维度堆叠，所以输入的一维数组必须长度相等</p></li>
<li><p>数组可以是n维，没有限制</p></li>
<li><p>np.hstack():horizontal_stack，将数组序列沿着第1维度堆叠</p></li>
<li><p>传入参数是数组序列</p></li>
<li><p>输入的数组除了第1维度，其余维度的形状必须相同</p></li>
<li><p>如果输入的都是一维数组，则会将一维数组变形为(1,n)，然后沿着第1维度堆叠，所以输入的一维数组长度不需要相等</p></li>
<li><p>数组可以是n维，没有限制</p></li>
<li><p>np.vstack()和np.hstack()如果根据函数的字面意义来理解，当它们处理2维数组时，是最符合其字面含义的</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line">b = np.arange(<span class="number">6</span>)</span><br><span class="line">np.vstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2, 3, 4, 5],
       [0, 1, 2, 3, 4, 5]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">b = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">np.vstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2],
       [3, 4, 5],
       [0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">b = np.arange(<span class="number">6</span>).reshape(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">np.vstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[[[0, 1, 2],
         [3, 4, 5]]],


       [[[0, 1, 2],
         [3, 4, 5]]]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">b = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">np.hstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 0, 1, 2],
       [2, 3, 3, 4, 5],
       [4, 5, 6, 7, 8]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line">b = np.arange(<span class="number">9</span>)</span><br><span class="line">np.hstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">b = np.arange(<span class="number">9</span>).reshape(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">np.hstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[[0, 1, 2],
        [3, 4, 5],
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">b = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a,b)))</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a,b)))</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1]
 [2 3]
 [4 5]
 [0 1]
 [2 3]
 [4 5]]
[[0 1 0 1]
 [2 3 2 3]
 [4 5 4 5]]</code></pre>
<ul>
<li><p>np.concatenate():将输入的数组序列沿着指定的已存在的维度堆叠</p></li>
<li><p>传入参数：数组序列和axis，用于指定维度</p></li>
<li><p>输入的数组序列除了在axis维度上可以形状不同，其余维度形状必须相同</p></li>
<li><p>axis默认是0，所以在默认形况下，concatenate()与vstack()相等；如果axis=None,那么输入序列需要先flatten成一维数组，然后进行拼接</p></li>
<li><p>np.stack():将输入的数组序列沿着一个新的维度进行堆叠</p></li>
<li><p>传入参数：数组序列和axis，axis用于指定新维度在结果数组形状中的index</p></li>
<li><p>传入的数组序列必须形状相同</p></li>
<li><p>axis默认是0，即将所有数组整个当作切片堆叠在一起，形成新的第0维度</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = np.arange(<span class="number">2</span>).reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1]
 [2 3]]
[[0 1]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.concatenate((a,b),axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1]
 [2 3]
 [0 1]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.concatenate((a,b.T),axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1 0]
 [2 3 1]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.concatenate((a,b),axis=<span class="literal">None</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 0 1]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line">b = np.arange(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3] [0 1]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.concatenate((a,b)))</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 0 1]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrays = [np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">stacked = np.stack(arrays)</span><br><span class="line"><span class="built_in">print</span>(stacked.shape)</span><br></pre></td></tr></table></figure>
<pre><code>(10, 3, 4)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stacked = np.stack(arrays,axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(stacked.shape)</span><br></pre></td></tr></table></figure>
<pre><code>(3, 10, 4)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stacked = np.stack(arrays,axis=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(stacked.shape)</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4, 10)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(np.stack((a,b),axis=-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[1 4]
 [2 5]
 [3 6]]</code></pre>
<h3 id="数组划分">2.3 数组划分</h3>
<ul>
<li><p>np.split()：将数组沿着指定维度，划分为指定的部分</p></li>
<li><p>传入参数：数组，axis（用于指定沿哪个维度划分），indices_or_sections</p></li>
<li><p>indices_or_sections如果是int,说明需要沿着维度将数组平等划分为若干部分，如果不能平等划分会报错</p></li>
<li><p>indices_or_sections如果是一维数组，说明需要沿着维度，按索引进行划分。如果输入是[2,3],则划分结果为[:2],[2:3],[3:]</p></li>
<li><p>np.hsplit()：与split()函数一样，但是沿着固定的第1维度进行划分</p></li>
<li><p>如果输入数组是一维数组，则沿着第0维度划分</p></li>
<li><p>np.vsplit()：与split()函数一样，但是沿着固定的第0维度进行划分</p></li>
<li><p>输入数组必须至少有2个维度</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">12</span>)</span><br><span class="line">np.split(a,<span class="number">3</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 0,  1,  2,  3],
        [12, 13, 14, 15]]),
 array([[ 4,  5,  6,  7],
        [16, 17, 18, 19]]),
 array([[ 8,  9, 10, 11],
        [20, 21, 22, 23]])]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.split(a,3,axis=0) # wrong</span></span><br><span class="line">np.split(a,<span class="number">2</span>,axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]]),
 array([[12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]])]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.split(a,[<span class="number">4</span>,<span class="number">8</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 0,  1,  2,  3],
        [12, 13, 14, 15]]),
 array([[ 4,  5,  6,  7],
        [16, 17, 18, 19]]),
 array([[ 8,  9, 10, 11],
        [20, 21, 22, 23]])]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(a,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 0,  1,  2,  3],
        [12, 13, 14, 15]]),
 array([[ 4,  5,  6,  7],
        [16, 17, 18, 19]]),
 array([[ 8,  9, 10, 11],
        [20, 21, 22, 23]])]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">np.hsplit(a,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([0, 1, 2, 3]), array([4, 5, 6, 7]), array([ 8,  9, 10, 11])]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a = np.arange(12)</span></span><br><span class="line"><span class="comment"># np.vsplit(a,3) #wrong</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">np.vsplit(a,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</code></pre>
<h2 id="拷贝和视图">3. 拷贝和视图</h2>
<p>当操作数组时，数组的数据有时候会进行拷贝，有时候不会进行拷贝。如果不分清，可能会造成数据混淆。一共有三种情况：完全不拷贝、浅拷贝（或视图）、深拷贝。
### 3.1 完全不拷贝
完全不拷贝一般有两种情况：第一种是简单赋值，第二种是可变对象作为参数传入函数
+
简单赋值：这种情况下，赋值的a和被赋值的b仅仅是同一个对象的不同名称。这是如果对b的对象进行修改，则a也会被修改。（注意分清哪些操作是原地执行，哪些不是）
+
可变对象作为函数的传入参数：如果函数调用时，传入参数是可变对象，那么执行的是引用传递，函数传入的变量和调用时的变量指向的是同一个对象。函数中变量如果修改了对象，则函数外的变量也会发生变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a) </span><br><span class="line">b.resize((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(a.shape) <span class="comment"># resize是原地执行</span></span><br></pre></td></tr></table></figure>
<pre><code>True
(3, 4)
(3, 4)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 3  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[ 3  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a) </span><br><span class="line">b.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(a.shape) <span class="comment"># reshape是创建一个新的对象</span></span><br></pre></td></tr></table></figure>
<pre><code>True
(12,)
(12,)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_value</span>(<span class="params">x</span>):</span><br><span class="line">    x[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">a=np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">change_value(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[0 1]
 [2 3]]
[[1 1]
 [2 3]]</code></pre>
<h3 id="视图或浅拷贝">3.2 视图或浅拷贝</h3>
<p>不同的数组可以共享同一组数据。比如对于数组a，可以创建它的一个视图b，则b就是一个新的数组对象，但与a共享数据。所以，浅拷贝就是只对原数组拷贝数组的相关属性，但是不拷贝数据。
+ 可以直接通过ndarray.view()函数来创建一个新视图 + 数组的切片也是视图 +
一些返回新数组对象的函数是浅拷贝，比如reshape()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a.view()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))  <span class="comment"># b是ndarray对象</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)  <span class="comment"># b与a不是同一个对象</span></span><br><span class="line"><span class="built_in">print</span>(b.base <span class="keyword">is</span> a)  <span class="comment"># b共享a的数据</span></span><br><span class="line"><span class="built_in">print</span>(b.flags.owndata, a.flags.owndata)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &#39;numpy.ndarray&#39;&gt;
False
True
False True</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(b.shape, a.shape)</span><br><span class="line">b.resize((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(b.shape, a.shape)  <span class="comment"># b的数组属性与a不共享</span></span><br></pre></td></tr></table></figure>
<pre><code>(12,) (12,)
(3, 4) (12,)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># b与a共享数据</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 1  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[ 1  1  2  3  4  5  6  7  8  9 10 11]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = a[:,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1  2]
 [ 5  6]
 [ 9 10]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">999</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[999   2]
 [  5   6]
 [  9  10]]
[[  0 999   2   3]
 [  4   5   6   7]
 [  8   9  10  11]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">999</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>False
[[999   1   2   3]
 [  4   5   6   7]
 [  8   9  10  11]]
[999   1   2   3   4   5   6   7   8   9  10  11]</code></pre>
<h3 id="深拷贝">3.3 深拷贝</h3>
<ul>
<li>ndarray.copy()函数可以完全复制原数组的属性和数据</li>
<li>有时，如果我们只需要一个巨大数组的一部分切片，那么就可以对原数组切片后使用copy()，然后释放原数组的内存(del)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a.copy()</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(b.base <span class="keyword">is</span> a)</span><br><span class="line">b[<span class="number">0</span>]=<span class="number">999</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>False
False
[999   1   2   3   4   5   6   7   8   9  10  11]
[ 0  1  2  3  4  5  6  7  8  9 10 11]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10000</span>)</span><br><span class="line">b = a[:<span class="number">100</span>].copy()</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71
 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
 96 97 98 99]</code></pre>
<h2 id="广播规则">4. 广播规则</h2>
<p>元素级的数组运算要求两个数组的形状完全相等，但是有了Numpy的广播机制，就可以放宽这个约束。</p>
<p>广播机制的一般规则如下： +
对参与运算的两个数组，Numpy会比较两者的形状是否兼容 +
从右到左地依次比较它们的维度大小 +
两者的维度个数不需要相等，对于缺失的维度，用1补充 +
两个数组在某个维度兼容，当且仅当两个数组该维度的大小相等，或者其中一个数组维度等于1
+ 只有两个数组在所有维度上都兼容，两个数组的形状才算兼容</p>
<ul>
<li>当两个数组的形状兼容时，就会进行广播</li>
<li>从右到左依次比较两个数组的维度大小，维度大小为1的需要映射到另一个较大的维度大小</li>
<li>最终结果的维度个数=输入数组中最大的维度个数，并且结果的每个维度大小=输入数组对应维度上最大的维度大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b = <span class="number">1</span>  </span><br><span class="line"><span class="built_in">print</span>(a+b)  <span class="comment">#标量广播到(4,5)</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [11 12 13 14 15]
 [16 17 18 19 20]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a+b)  <span class="comment">#wrong，因为(4,)无法广播到(4,5)，广播机制是从右到左对齐的</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

Cell In [113], line 2
      1 b = np.array([1,1,1,1])
----&gt; 2 print(a+b)


ValueError: operands could not be broadcast together with shapes (4,5) (4,) </code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [11 12 13 14 15]
 [16 17 18 19 20]]</code></pre>
<h2 id="高级索引">5. 高级索引</h2>
<p>numpy中数组除了可以用Integer和切片进行索引，还支持更多索引方式（python序列不支持），包括用整型数组和布尔数组进行索引。
### 5.1 整型数组索引 + ndarray可以用ndarray进行索引 +
如果使用单个数组进行索引，它只对被索引数组的第0维度进行索引。比如A的shape为(2,3,4)，索引数组B的shape为(3,3)并且每个元素的取值都是[0,2)区间内的整型，那么A[B]的形状为(3,3,3,4)
+
如果想对数组的多个维度进行索引，就需要多个索引数组，它们的形状必须相同，并且这些索引数组对应位置上的元素组成一个完整的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a[b])</span><br><span class="line"><span class="built_in">print</span>(a[b].shape)</span><br></pre></td></tr></table></figure>
<pre><code>[1 2 3]
(3,)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a[c])</span><br><span class="line"><span class="built_in">print</span>(a[c].shape)</span><br></pre></td></tr></table></figure>
<pre><code>[[1 2 3]
 [4 5 6]]
(2, 3)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">palatte = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],</span><br><span class="line">          [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]])</span><br><span class="line"></span><br><span class="line">pixel = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">image = palatte[pixel]</span><br><span class="line"><span class="built_in">print</span>(image)</span><br><span class="line"><span class="built_in">print</span>(image.shape)</span><br></pre></td></tr></table></figure>
<pre><code>[[[  0   0   0]
  [255   0   0]
  [  0 255   0]
  [  0   0 255]]

 [[  0   0 255]
  [  0 255   0]
  [255 255 255]
  [255   0   0]]

 [[  0 255   0]
  [  0   0 255]
  [255 255 255]
  [  0   0   0]]

 [[255 255 255]
  [  0   0 255]
  [  0 255   0]
  [255   0   0]]]
(4, 4, 3)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">i = np.array([[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]])  <span class="comment">#第1维度的索引</span></span><br><span class="line">j = np.array([[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">1</span>]])  <span class="comment">#第2维度的索引</span></span><br><span class="line"><span class="built_in">print</span>(a[i,j])</span><br><span class="line"><span class="built_in">print</span>(a[i,j].shape)</span><br></pre></td></tr></table></figure>
<pre><code>[[18 14]
 [ 5 16]]
(2, 2)</code></pre>
<h3 id="布尔数组索引">5.2 布尔数组索引</h3>
<p>在整型数组索引中，我们需要提供索引数组，来定位想要Pick的元素。而用布尔数组索引时，我们需要显式地说明我们想要哪些元素，不想要哪些元素。
+ 第一种方式是，提供一个与原数组shape完全相等的布尔数组作为索引 +
用布尔数组去索引原数组，返回的是1维数组 + 布尔数组索引在赋值时非常好用 +
第二种方式是，提供若干个一维的布尔数组，每个一维的布尔数组索引一个维度，其长度需要与原数组对应维度大小相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = a&gt;<span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>[[False False False False]
 [False  True  True  True]
 [ True  True  True  True]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b]</span><br></pre></td></tr></table></figure>
<pre><code>array([ 5,  6,  7,  8,  9, 10, 11])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[b] = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4 -1 -1 -1]
 [-1 -1 -1 -1]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>]) <span class="comment">#第0维度布尔索引</span></span><br><span class="line">a[b]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4, -1, -1, -1],
       [-1, -1, -1, -1]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.array([<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>]) <span class="comment">#第1维度布尔索引</span></span><br><span class="line"><span class="built_in">print</span>(a[:,c])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1  3]
 [-1 -1]
 [-1 -1]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[b,c] <span class="comment">#结果只有2个元素，因为这里多个1维布尔数组进行索引的逻辑，和多个整型数组进行索引的逻辑相同</span></span><br><span class="line"><span class="comment"># 将每个布尔数组里为True的index抽取出来作为索引，这些1维索引的形状必须相同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([-1, -1])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b,[<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>]] <span class="comment">#(2,)和(3,) 形状不同，不能进行索引</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

Cell In [14], line 1
----&gt; 1 a[b,[False,True,True,True]]


IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (3,) </code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b,[<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>]] <span class="comment">#(2,)和scalar，scalar可以广播到(2,)</span></span><br></pre></td></tr></table></figure>
<pre><code>array([-1, -1])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://laaambs.github.io">Sunset</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://laaambs.github.io/2023/08/25/NumPy-Quick-Start/">https://laaambs.github.io/2023/08/25/NumPy-Quick-Start/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://laaambs.github.io" target="_blank">Sunset's Citywalk</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81/">代码</a><a class="post-meta__tags" href="/tags/NumPy/">NumPy</a></div><div class="post_share"><div class="social-share" data-image="/images/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/18/Attention-Is-All-You-Need/" title="Attention Is All You Need"><img class="cover" src="/images/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Attention Is All You Need</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/26/BERT-Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding/" title="BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding"><img class="cover" src="/images/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/rabbit.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sunset</div><div class="author-info__description">Fight for your faiytale.❤</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/laaambs"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/laaambs" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:894699297@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#numpy---quick-start"><span class="toc-text">NumPy - Quick Start</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1. 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ndarray%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="toc-text">1.1 ndarray的主要属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="toc-text">1.2 数组创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8python%E5%BA%8F%E5%88%97%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-text">1.2.1 用python序列创建数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%9C%AA%E7%9F%A5%E6%97%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">1.2.2
元素未知时创建一定大小的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E9%87%87%E6%A0%B7%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-text">1.2.3 从指定区间采样创建数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84"><span class="toc-text">1.3 打印数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">1.4 基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">1.5 通函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%87%E7%89%87%E5%92%8C%E8%BF%AD%E4%BB%A3"><span class="toc-text">1.6 索引、切片和迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E7%8A%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">2. 形状操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%A2%E7%8A%B6"><span class="toc-text">2.1 修改数组的形状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%A0%86%E5%8F%A0"><span class="toc-text">2.2 不同的数组进行堆叠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86"><span class="toc-text">2.3 数组划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%A7%86%E5%9B%BE"><span class="toc-text">3. 拷贝和视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E6%88%96%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">3.2 视图或浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">3.3 深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E8%A7%84%E5%88%99"><span class="toc-text">4. 广播规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">5. 高级索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="toc-text">5.2 布尔数组索引</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By Sunset</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>